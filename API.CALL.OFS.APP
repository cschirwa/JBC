SUBROUTINE API.CALL.OFS.APP(V$OFS.SOURCE, V$APP.VERSION, V$FUNCTION, V$USER, V$PASS, V$ID, V$FLDVAL, V$RESULT)
*-------------------------------------------------------------------------------------------------------------
* DESCRIPTION:
*
* API routine
*
* Build and process OFS message based on information supplied.
* 
* Example:
*   CALL API.CALL.OFS('', 'FT,DEMO', 'I', '', '', 'FT00000001', 'SHORT.NAME=TEST':@FM:'STREET=TEST', V$RESULT)
*_______________________________________________________________________________
* INCOMING PARAMETERS:
*
* V$OFS.SOURCE     - ID of OFS.SOURCE (can be empty for ONLINE processing)
* V$APP.VERSION    - APPLICATION or APPLICATION,VERSION to run
* V$FUNCTION<1>    - Function to use (I/VALIDATE)
* V$FUNCTION<2, 1> - Set to 'ONLINE' for process message immediately or 'MSG' to get formated OFS request
* V$FUNCTION<2, 2> - Timeout in seconds for ONLINE processing (default is 20sec)
* V$USER           - SIGN.ON.NAME (can be empty, for current user)
* V$PASS           - PASSWORD (can be empty, for current user or BATCH OFS.SOURCE)
* V$ID             - ID of record to work with; empty means generate a new one
* V$FLDVAL         - Field name ..=.. Field value
*_______________________________________________________________________________
* RETURNED DATA:
*
* V$ID            - ID generated by OFS call
* V$RESULT     <1> - Return status (1=OK, -1/-2/-3=error occurred)
*              <2> - Output error message from OFS (if error occurred, otherwise OK)
*              <3> - OFS formatted initial message
*              <4> - OFS formatted resulting message
*_______________________________________________________________________________
* NOTES:
*_______________________________________________________________________________
* CHANGELOG:
* ID YYYYMMDD 	FLASTNAME 		DESCRIPTION
* 01 20241120 - Calvin@ACCESS 	Initial Dev 
********************************************************************************
* <Rating>111</Rating>
********************************************************************************

$INSERT I_COMMON
$INSERT I_GTS.COMMON
$INSERT I_F.USER
$INSERT I_F.SPF
$INSERT I_F.OFS.SOURCE

********************************************************************************

EQU REQUEST.TIMEOUT TO 20 ;* in seconds
EQU SCHEDULE.DELIMITER TO '//'

********************************************************************************
   V$RESULT = ''
   
   * get current user 
   IF NOT(V$USER) THEN
      V$USER = R.USER<EB.USE.SIGN.ON.NAME>
      IF NOT(V$USER) THEN
         V$USER = 'INPUTT'
      END
   END

   * Build header
   L$OFS.MSG = V$APP.VERSION[',', 1, 1]:',':V$APP.VERSION[',', 2, 1]:'/'
   L$OFS.MSG := V$FUNCTION<1>:','
   L$OFS.MSG := V$USER:'/':V$PASS:','
   L$OFS.MSG := CHANGE(V$ID, ',', '?'):','
   
   * Build body
   TEMP.BODY = ''
   I.LEN = DCOUNT(V$FLDVAL, @FM)
   FOR I = 1 TO I.LEN
      L$FLDVAL = V$FLDVAL<I>
      L$FLD = L$FLDVAL['=', 1, 1]
      IF L$FLD = SCHEDULE.DELIMITER THEN
         TEMP.BODY = TEMP.BODY[1, -2]:SCHEDULE.DELIMITER
      END ELSE

         IF NOT(INDEX(L$FLD, ':', 1)) THEN
            L$FLD := '::'
         END
         TEMP.BODY := L$FLD:'=':CHANGE(L$FLDVAL['=', 2, DCOUNT(L$FLDVAL, '=')], ',', '?'):','
      END
   NEXT I
   
   * append body to request message
   IF TEMP.BODY[1] = ',' THEN
      L$OFS.MSG := TEMP.BODY[1, -2]
   END ELSE
      L$OFS.MSG := TEMP.BODY
   END

   * fill result with request message
   V$RESULT<3> = L$OFS.MSG
  
   
   * return only formated ofs request message
   IF V$FUNCTION<2, 1> = 'MSG' THEN
      V$RESULT<1> = 1
      RETURN
   END
   

   * processing with R05 globus manager
   IF V$OFS.SOURCE AND TRANS('F.SPF', 'SYSTEM', SPF.CURRENT.RELEASE, 'X')[1, 3] = 'R05' THEN
      SENSITIVITY = ''
      CALL OFS.GLOBUS.MANAGER(V$OFS.SOURCE, L$OFS.MSG)
      SENSITIVITY = ''
      
      OFS.BODY = L$OFS.MSG[INDEX(L$OFS.MSG, '/', 2), -1]
      OFS.BODY = OFS.BODY[INDEX(OFS.BODY, ',', 1) + 1, -1]
      
      V$RESULT<1> = L$OFS.MSG['/', 3, 1][',', 1, 1]
      V$RESULT<4> = ',':L$OFS.MSG['/', 1, 1]
      IF V$RESULT<1> = 1 THEN
         V$RESULT<2> = 'OK'
         V$ID = L$OFS.MSG['/', 1, 1]
      END ELSE
         V$RESULT<2> = OFS.BODY
         IF NOT(V$ID) THEN
            V$ID = L$OFS.MSG['/', 1, 1]
         END
      END      
      
      RETURN
   END

   * process OFS (POST)
   IF V$FUNCTION<2, 1> <> 'ONLINE' THEN
      CALL OFS.POST.MESSAGE(L$OFS.MSG, V$ID, V$OFS.SOURCE, '')   
 
      V$RESULT<1> = 1
      V$RESULT<2> = 'OK'
      V$RESULT<4> = ',':V$ID; * in a lot of subroutines the ofs result
      RETURN
   END
   
   * process OFS (ONLINE)
   OFS.REQUEST.ID = ''
   CALL ALLOCATE.UNIQUE.TIME(OFS.REQUEST.ID)
   OFS.REQUEST.ID = DATE():OFS.REQUEST.ID
   EXECUTE 'API.CALL.OFS.PHANTOM -Jb ':OCONV(V$OFS.SOURCE:@FM:OFS.REQUEST.ID:@FM:L$OFS.MSG, 'MX') CAPTURING OUTPUT

   * waiting for response
   R.OFS.RESPONSE.QUEUE = ''
   OPEN 'F.OFS.RESPONSE.QUEUE' TO F.OFS.RESPONSE.QUEUE SETTING X THEN
		IF V$FUNCTION<2, 2> THEN 
			TIME.OUT = V$FUNCTION<2, 2> 
		END ELSE 
			TIME.OUT = REQUEST.TIMEOUT * 4
		END 
      LOOP
         TIME.OUT--
      WHILE TIME.OUT >= 0 AND NOT(R.OFS.RESPONSE.QUEUE)
         READ R.OFS.RESPONSE.QUEUE FROM F.OFS.RESPONSE.QUEUE, OFS.REQUEST.ID ELSE
            MSLEEP 100
         END
      REPEAT

      * force close phantom app
      IF NOT(R.OFS.RESPONSE.QUEUE) THEN
         READ R.PID FROM F.OFS.RESPONSE.QUEUE, OFS.REQUEST.ID:'.PID' THEN
            EXECUTE 'jkill -q ':R.PID<1>
         END
      END
   END

   IF NOT(R.OFS.RESPONSE.QUEUE) THEN
      R.OFS.RESPONSE.QUEUE = '-1':@FM:'OFS.ERROR:1:1=RESPONSE TIMEOUT'
   END
   
   * parse to OLD response format
   V$RESULT<1> = R.OFS.RESPONSE.QUEUE<1>
   V$RESULT<4> = ',':R.OFS.RESPONSE.QUEUE<3>
   IF R.OFS.RESPONSE.QUEUE<1> = 1 THEN
      V$RESULT<2> = 'OK'
      V$ID = R.OFS.RESPONSE.QUEUE<3>
   END ELSE
      V$RESULT<2> =  R.OFS.RESPONSE.QUEUE<2>
      IF NOT(V$ID) THEN
         V$ID = R.OFS.RESPONSE.QUEUE<3>
      END
   END

END
